<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Expo Games WebSocket API 文檔</title>
    <link rel="stylesheet" href="/static/css/websocket-docs.css">
    <script src="/static/js/websocket-docs.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔌 Expo Games WebSocket API Documentation</h1>
            <p>Complete WebSocket endpoints for real-time communication</p>
        </div>

        <!-- 連接狀態指示器 -->
        <div class="endpoint-card">
            <div class="endpoint-header">
                <div>
                    <span class="status-indicator status-disconnected" id="connectionStatus"></span>
                    <strong>WebSocket 連接狀態</strong>
                    <div class="endpoint-description">目前連接狀態和控制</div>
                </div>
            </div>
            <div class="endpoint-content">
                <div class="test-section">
                    <h4>🔗 連接測試</h4>
                    <div class="input-group">
                        <label>WebSocket URL:</label>
                        <input type="text" id="wsUrl" value="" readonly>
                    </div>
                    <div class="test-controls">
                        <button class="btn btn-primary" id="connectBtn">連接</button>
                        <button class="btn btn-danger" id="disconnectBtn">斷開</button>
                        <button class="btn btn-success" id="clearLogBtn">清除日誌</button>
                    </div>
                    <div class="log-area" id="logArea">等待連接...\n</div>
                </div>
            </div>
        </div>

        <!-- 情緒分析 WebSocket -->
        <div class="endpoint-card">
            <div class="endpoint-header" onclick="toggleEndpoint(this)">
                <div>
                    <span class="endpoint-method">WS</span>
                    <span class="endpoint-url">/ws/emotion</span>
                    <div class="endpoint-description">即時情緒分析串流</div>
                </div>
                <span class="toggle-arrow">▶</span>
            </div>
            <div class="endpoint-content">
                <div class="section">
                    <h3>📋 功能說明</h3>
                    <p>處理即時攝影機影像串流，進行情緒分析並返回結果。支援心跳機制和自動重連。</p>
                </div>

                <div class="section">
                    <h3>📤 客戶端發送訊息</h3>

                    <div class="message-example">
                        <div class="message-type">影像幀訊息 (Frame Message)</div>
                        <pre>{
  "type": "frame",
  "image": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQ...",
  "timestamp": 1640995200.123
}</pre>
                        <p><strong>說明</strong>：持續發送攝影機幀進行即時分析，建議 5-10 FPS</p>
                    </div>

                    <div class="message-example">
                        <div class="message-type">心跳訊息 (Ping Message - 可選)</div>
                        <pre>{
  "type": "ping",
  "timestamp": 1640995200.123
}</pre>
                        <p><strong>說明</strong>：心跳為可選功能，因為持續的幀數據已起到保活作用</p>
                    </div>
                </div>

                <div class="section">
                    <h3>📥 服務器回應訊息</h3>

                    <div class="message-example">
                        <div class="message-type">分析結果 (Result Message)</div>
                        <pre>{
  "type": "result",
  "emotion_zh": "開心",
  "emotion_en": "happy",
  "emoji": "😊",
  "confidence": 0.95,
  "timestamp": 1640995200.123,
  "frame_time": 1640995200.123
}</pre>
                    </div>

                    <div class="message-example">
                        <div class="message-type">錯誤訊息 (Error Message)</div>
                        <pre>{
  "type": "error",
  "message": "影像分析錯誤: 無法檢測到人臉",
  "timestamp": 1640995200.123
}</pre>
                    </div>

                    <div class="message-example">
                        <div class="message-type">心跳回應 (Pong Response)</div>
                        <pre>"pong"</pre>
                        <p><strong>說明</strong>：服務端回應純文本 "pong"，不是 JSON 格式</p>
                    </div>
                </div>

                <div class="section">
                    <h3>🔌 連接管理</h3>
                    
                    <h4>連接方式</h4>
                    <div class="code-block">// 直接連接，無需 open 訊息
const ws = new WebSocket('ws://localhost:8896/ws/emotion');

ws.onopen = () => {
    console.log('已連接，可以開始發送影像幀');
    // 無需發送 open 訊息，直接發送 frame
};
</div>

                    <h4>停止會話</h4>
                    <div class="code-block">// 方法 1: 直接關閉連接（推薦）
ws.close(1000, '用戶主動關閉');

// 方法 2: 停止發送幀，保持連接
// 只要停止發送 frame 訊息即可，不需要特殊的停止訊息
clearInterval(frameInterval);
</div>

                    <h4>關閉代碼說明</h4>
                    <div class="code-block">// 正常關閉 (1000) - 推薦用於用戶主動關閉
ws.close(1000, '情緒分析會話結束');

// 異常關閉 (1006) - 網路中斷或服務器崩潰
// 通常由瀏覽器自動處理，不需要手動發送

// 服務器錯誤 (1011) - 內部處理錯誤
// 由服務器發送，前端通常接收到此代碼

// 監聽關閉事件
ws.onclose = (event) => {
    console.log('WebSocket 關閉:', {
        code: event.code,
        reason: event.reason,
        wasClean: event.wasClean
    });

    // 根據關閉代碼處理不同情況
    switch(event.code) {
        case 1000:
            console.log('正常關閉');
            break;
        case 1001:
            console.log('端點離開，頁面可能重新載入');
            break;
        case 1006:
            console.log('異常關閉，嘗試重連');
            // 實現重連邏輯
            break;
        case 1011:
            console.log('服務器錯誤');
            break;
        default:
            console.log('其他關閉代碼:', event.code);
    }
};
</div>

                    <h4>心跳機制（可選）</h4>
                    <div class="code-block">// 如果需要額外的心跳保活
setInterval(() => {
    if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'ping' }));
    }
}, 30000); // 每 30 秒一次
</div>
                </div>

                <div class="section">
                    <h3>⚙️ 效能參數</h3>
                    <table class="table">
                        <tr><th>參數</th><th>建議值</th><th>說明</th></tr>
                        <tr><td>幀率</td><td>5-10 FPS</td><td>視網路和處理能力而定</td></tr>
                        <tr><td>影像解析度</td><td>動態適應</td><td>自動適應攝影機實際解析度 (如 1920x1080, 1280x720 等)</td></tr>
                        <tr><td>壓縮品質</td><td>0.8 JPEG</td><td>平衡檔案大小和品質</td></tr>
                        <tr><td>網路延遲</td><td>< 200ms</td><td>建議延遲上限</td></tr>
                    </table>
                </div>

                <div class="section">
                    <h3>💻 使用範例</h3>
                    <div class="code-block">// JavaScript 動態解析度影像串流範例
class EmotionStreamClient {
    constructor() {
        this.websocket = null;
        this.videoSize = [640, 480]; // 默認值，會動態調整
        this.captureCanvas = null;
        this.captureContext = null;
    }

    async initializeCamera() {
        // 請求攝影機權限
        const stream = await navigator.mediaDevices.getUserMedia({
            video: { width: { ideal: 640 }, height: { ideal: 480 } }
        });

        // 動態獲取實際解析度
        const videoTrack = stream.getVideoTracks()[0];
        const settings = videoTrack.getSettings();
        this.videoSize = [
            settings.width || 640,
            settings.height || 480
        ];

        console.log('攝影機實際解析度:', this.videoSize);

        // 創建動態尺寸的捕獲畫布
        this.captureCanvas = document.createElement('canvas');
        this.captureCanvas.width = this.videoSize[0];
        this.captureCanvas.height = this.videoSize[1];
        this.captureContext = this.captureCanvas.getContext('2d');

        // 設置video元素
        const videoElement = document.createElement('video');
        videoElement.srcObject = stream;
        videoElement.play();

        return videoElement;
    }

    startStreaming(videoElement) {
        // 定期發送影像幀
        setInterval(() => {
            if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                // 使用動態解析度捕獲影像
                this.captureContext.drawImage(videoElement, 0, 0, this.videoSize[0], this.videoSize[1]);
                const imageData = this.captureCanvas.toDataURL('image/jpeg', 0.8);

                const message = {
                    type: 'frame',
                    image: imageData,
                    timestamp: Date.now() / 1000
                };

                this.websocket.send(JSON.stringify(message));
            }
        }, 200); // 5 FPS
    }
}</div>
                </div>
            </div>
        </div>

        <!-- 動作檢測 WebSocket -->
        <div class="endpoint-card">
            <div class="endpoint-header" onclick="toggleEndpoint(this)">
                <div>
                    <span class="endpoint-method">WS</span>
                    <span class="endpoint-url">/ws/action</span>
                    <div class="endpoint-description">動作檢測狀態廣播</div>
                </div>
                <span class="toggle-arrow">▶</span>
            </div>
            <div class="endpoint-content">
                <div class="section">
                    <h3>📋 功能說明</h3>
                    <p>即時廣播動作檢測遊戲的狀態更新和結果。</p>
                </div>

                <div class="section">
                    <h3>🔌 連接管理</h3>

                    <h4>連接方式</h4>
                    <div class="code-block">// 廣播型 WebSocket，無需發送訊息即可接收狀態更新
const ws = new WebSocket('ws://localhost:8896/ws/action');

ws.onopen = () => {
    console.log('已連接動作檢測廣播');
    // 無需發送任何訊息，直接接收廣播
};
</div>

                    <h4>關閉連接</h4>
                    <div class="code-block">// 正常關閉 (1000) - 用戶主動斷開
ws.close(1000, '停止接收動作檢測廣播');

// 監聽關閉事件
ws.onclose = (event) => {
    console.log('動作檢測 WebSocket 關閉:', {
        code: event.code,
        reason: event.reason,
        wasClean: event.wasClean
    });

    // 根據關閉代碼處理
    switch(event.code) {
        case 1000:
            console.log('正常關閉廣播連接');
            break;
        case 1006:
            console.log('廣播連接異常中斷');
            break;
        default:
            console.log('廣播連接關閉，代碼:', event.code);
    }
};
</div>
                </div>

                <div class="section">
                    <h3>📥 廣播訊息格式</h3>

                    <div class="message-example">
                        <div class="message-type">遊戲開始 (Game Start)</div>
                        <pre>{
  "channel": "action",
  "type": "game_start",
  "difficulty": "medium",
  "timestamp": 1640995200.123
}</pre>
                    </div>

                    <div class="message-example">
                        <div class="message-type">檢測結果 (Detection Result)</div>
                        <pre>{
  "channel": "action",
  "type": "detection_result",
  "action": "jump",
  "confidence": 0.87,
  "timestamp": 1640995200.123
}</pre>
                    </div>

                    <div class="message-example">
                        <div class="message-type">狀態更新 (Status Update)</div>
                        <pre>{
  "channel": "action",
  "type": "status_update",
  "status": "running",
  "current_action": "raise_hand",
  "time_remaining": 45.2,
  "timestamp": 1640995200.123
}</pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- 手勢識別 WebSocket -->
        <div class="endpoint-card">
            <div class="endpoint-header" onclick="toggleEndpoint(this)">
                <div>
                    <span class="endpoint-method">WS</span>
                    <span class="endpoint-url">/ws/gesture</span>
                    <div class="endpoint-description">手勢識別結果廣播</div>
                </div>
                <span class="toggle-arrow">▶</span>
            </div>
            <div class="endpoint-content">
                <div class="section">
                    <h3>📋 功能說明</h3>
                    <p>即時廣播手勢識別結果和狀態更新。</p>
                </div>

                <div class="section">
                    <h3>🔌 連接管理</h3>

                    <h4>連接方式</h4>
                    <div class="code-block">// 廣播型 WebSocket，無需發送訊息即可接收手勢辨識結果
const ws = new WebSocket('ws://localhost:8896/ws/gesture');

ws.onopen = () => {
    console.log('已連接手勢識別廣播');
    // 無需發送任何訊息，直接接收廣播
};
</div>

                    <h4>關閉連接</h4>
                    <div class="code-block">// 正常關閉 (1000) - 用戶主動停止接收
ws.close(1000, '停止接收手勢識別廣播');

// 監聽關閉事件
ws.onclose = (event) => {
    console.log('手勢識別 WebSocket 關閉:', {
        code: event.code,
        reason: event.reason,
        wasClean: event.wasClean
    });

    // 根據關閉代碼處理
    switch(event.code) {
        case 1000:
            console.log('正常關閉手勢廣播連接');
            break;
        case 1006:
            console.log('手勢廣播連接異常中斷');
            break;
        default:
            console.log('手勢廣播連接關閉，代碼:', event.code);
    }
};
</div>
                </div>

                <div class="section">
                    <h3>📥 廣播訊息格式</h3>

                    <div class="message-example">
                        <div class="message-type">手勢檢測 (Gesture Detected)</div>
                        <pre>{
  "channel": "gesture",
  "type": "gesture_detected",
  "gesture": "thumbs_up",
  "confidence": 0.92,
  "timestamp": 1640995200.123
}</pre>
                    </div>

                    <div class="message-example">
                        <div class="message-type">狀態更新 (Status Update)</div>
                        <pre>{
  "channel": "gesture",
  "type": "status_update",
  "status": "running",
  "uptime": 30,
  "timestamp": 1640995200.123
}</pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- 猜拳整合式 WebSocket (MediaPipe 版本) -->
        <div class="endpoint-card">
            <div class="endpoint-header" onclick="toggleEndpoint(this)">
                <div>
                    <span class="endpoint-method">WS</span>
                    <span class="endpoint-url">/ws/rps</span>
                    <div class="endpoint-description">猜拳遊戲</div>
                </div>
                <span class="toggle-arrow">▶</span>
            </div>
            <div class="endpoint-content">
                <div class="section">
                    <h3>📋 功能說明</h3>
                    <p><strong>單一 WebSocket 整合所有功能</strong>：遊戲控制 + 即時影像串流辨識 + 狀態廣播</p>
                    <p><strong>技術架構</strong>：MediaPipe 即時辨識 + 單一 WebSocket 雙向通訊 + 自動手勢提交</p>
                    <p><strong>優勢</strong>：開發者只需連線一個端點，簡化整合流程</p>
                </div>

                <div class="section">
                    <h3>📤 客戶端發送訊息</h3>

                    <div class="message-example">
                        <div class="message-type">心跳訊息 (Ping Message)</div>
                        <pre>{
  "type": "ping"
}</pre>
                        <p><strong>說明</strong>：保持連接活躍的可選訊息</p>
                    </div>

                    <div class="message-example">
                        <div class="message-type">遊戲控制 (Game Control)</div>
                        <pre>{
  "type": "game_control",
  "action": "start_game",
  "target_score": 1
}</pre>
                        <p><strong>action 值</strong>：<code>"start_game"</code>, <code>"stop_game"</code></p>
                        <p><strong>說明</strong>：開始或停止遊戲會話</p>
                        <p><strong>target_score</strong>：固定為 1（單回合模式），保留為 API 相容性</p>
                    </div>

                    <div class="message-example">
                        <div class="message-type">影像幀 (Frame Message)</div>
                        <pre>{
  "type": "frame",
  "image": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQ...",
  "timestamp": 1640995200.123
}</pre>
                        <p><strong>說明</strong>：持續發送攝影機幀進行即時手勢辨識，建議 5 FPS</p>
                    </div>
                </div>

                <div class="section">
                    <h3>📥 服務器回應訊息</h3>

                    <div class="message-example">
                        <div class="message-type">控制確認 (Control Ack)</div>
                        <pre>{
  "type": "control_ack",
  "action": "start_game",
  "status": "started",
  "message": "遊戲已開始"
}</pre>
                        <p><strong>說明</strong>：對遊戲控制指令的回應</p>
                    </div>

                    <div class="message-example">
                        <div class="message-type">辨識結果 (Recognition Result)</div>
                        <pre>{
  "type": "recognition_result",
  "gesture": "rock",
  "confidence": 0.96,
  "timestamp": 1640995200.123,
  "is_valid": true
}</pre>
                        <p><strong>gesture 值</strong>：<code>"rock"</code>, <code>"paper"</code>, <code>"scissors"</code>, <code>"unknown"</code></p>
                        <p><strong>說明</strong>：即時手勢辨識結果</p>
                    </div>

                    <div class="message-example">
                        <div class="message-type">遊戲狀態 (Game State)</div>
                        <pre>{
  "type": "game_state",
  "stage": "waiting_player",
  "message": "等待玩家出拳",
  "data": {
    "round": 1,
    "scores": {"player": 0, "computer": 0}
  }
}</pre>
                        <p><strong>說明</strong>：遊戲狀態廣播訊息</p>
                    </div>

                    <div class="message-example">
                        <div class="message-type">錯誤訊息 (Error Message)</div>
                        <pre>{
  "type": "error",
  "message": "辨識失敗",
  "timestamp": 1640995200.123
}</pre>
                    </div>

                    <div class="message-example">
                        <div class="message-type">心跳回應 (Pong Response)</div>
                        <pre>{
  "type": "pong"
}</pre>
                        <p><strong>說明</strong>：對 ping 訊息的回應</p>
                    </div>
                </div>

                <div class="section">
                    <h3>🎮 遊戲狀態廣播格式（8 種階段）</h3>

                    <div class="message-example">
                        <div class="message-type">1️⃣ 遊戲開始 (game_started)</div>
                        <pre>{
  "channel": "rps_game",
  "stage": "game_started",
  "message": "猜拳遊戲開始！",
  "data": {
    "target_score": 1,
    "player_score": 0,
    "computer_score": 0
  },
  "timestamp": 1640995200.123
}</pre>
                        <p><strong>說明</strong>：單回合模式，一次對決後自動結束</p>
                    </div>

                    <div class="message-example">
                        <div class="message-type">2️⃣ 回合開始 (round_started)</div>
                        <pre>{
  "channel": "rps_game",
  "stage": "round_started",
  "message": "第 1 回合開始",
  "data": {
    "round": 1,
    "scores": {"player": 0, "computer": 0}
  },
  "timestamp": 1640995200.123
}</pre>
                    </div>

                    <div class="message-example">
                        <div class="message-type">3️⃣ 倒數計時 (countdown)</div>
                        <pre>{
  "channel": "rps_game",
  "stage": "countdown",
  "message": "倒數: 3",
  "data": {"count": 3},
  "timestamp": 1640995200.123
}</pre>
                        <p><strong>前端建議</strong>：使用大尺寸數字動畫顯示倒數，參考 CSS 動畫 <code>countdownPulse</code></p>
                    </div>

                    <div class="message-example">
                        <div class="message-type">4️⃣ 等待玩家出拳 (waiting_player)</div>
                        <pre>{
  "channel": "rps_game",
  "stage": "waiting_player",
  "message": "請上傳你的手勢！",
  "data": {},
  "timestamp": 1640995200.123
}</pre>
                        <p><strong>說明</strong>：等待玩家手勢辨識，系統會自動透過 WebSocket 即時辨識攝影機影像</p>
                        <p><strong>自動設定</strong>：當手勢信心度 > 60% 時，後端自動設定玩家手勢</p>
                        <p><strong>超時處理</strong>：最多等待 10 秒，若未辨識到有效手勢則視為 UNKNOWN</p>
                    </div>

                    <div class="message-example">
                        <div class="message-type">5️⃣ 回合結果 (result)</div>
                        <pre>{
  "channel": "rps_game",
  "stage": "result",
  "message": "你贏了！",
  "data": {
    "result": "win",
    "gestures": {
      "player": "rock",
      "computer": "scissors"
    },
    "scores": {"player": 1, "computer": 0},
    "round": 1
  },
  "timestamp": 1640995200.123
}</pre>
                        <p><strong>result 值</strong>：<code>"win"</code>, <code>"lose"</code>, <code>"draw"</code></p>
                    </div>

                    <div class="message-example">
                        <div class="message-type">6️⃣ 遊戲結束 (game_finished)</div>
                        <pre>{
  "channel": "rps_game",
  "stage": "game_finished",
  "message": "遊戲結束！玩家獲勝！",
  "data": {
    "winner": "player",
    "final_scores": {"player": 3, "computer": 1},
    "total_rounds": 4,
    "duration": 45.2
  },
  "timestamp": 1640995200.123
}</pre>
                    </div>

                    <div class="message-example">
                        <div class="message-type">7️⃣ 遊戲停止 (game_stopped)</div>
                        <pre>{
  "channel": "rps_game",
  "stage": "game_stopped",
  "message": "遊戲已停止",
  "data": {
    "reason": "user_request",
    "final_scores": {"player": 1, "computer": 1}
  },
  "timestamp": 1640995200.123
}</pre>
                    </div>

                    <div class="message-example">
                        <div class="message-type">8️⃣ 錯誤訊息 (error)</div>
                        <pre>{
  "channel": "rps_game",
  "stage": "error",
  "message": "超時未出拳，本回合判定失敗",
  "data": {
    "error_type": "timeout",
    "round": 2
  },
  "timestamp": 1640995200.123
}</pre>
                    </div>
                </div>

                <div class="section">
                    <h3>🎮 完全 WebSocket 架構</h3>
                    <p>RPS 遊戲完全透過 WebSocket 控制，不使用 REST API：</p>
                    <ul>
                        <li>✅ 遊戲控制透過 <code>game_control</code> 訊息</li>
                        <li>✅ 影像串流透過 <code>frame</code> 訊息</li>
                        <li>✅ 狀態更新透過 <code>game_state</code> 廣播</li>
                        <li>✅ 自動手勢辨識（信心度 > 60%）</li>
                    </ul>
                </div>

                <div class="section">
                    <h3>🔌 連接管理</h3>

                    <h4>連接方式</h4>
                    <div class="code-block">// 整合式 WebSocket，支援遊戲控制和即時串流
const ws = new WebSocket('ws://localhost:8896/ws/rps');

ws.onopen = () => {
    console.log('已連接猜拳遊戲 WebSocket');
    // 連接後可以開始發送 game_control 訊息或 frame 訊息
};
</div>

                    <h4>關閉連接</h4>
                    <div class="code-block">// 正常關閉 (1000) - 用戶結束遊戲會話
ws.close(1000, '猜拳遊戲會話結束');

// 遊戲停止 (1000) - 透過 stop_game 訊息後關閉
// 先發送 stop_game 訊息，收到 game_stopped 回應後關閉
ws.send(JSON.stringify({
    type: 'game_control',
    action: 'stop_game'
}));
// 等待 game_stopped 回應，然後:
ws.close(1000, '遊戲正常結束');

// 監聽關閉事件
ws.onclose = (event) => {
    console.log('猜拳遊戲 WebSocket 關閉:', {
        code: event.code,
        reason: event.reason,
        wasClean: event.wasClean
    });

    // 根據關閉代碼處理
    switch(event.code) {
        case 1000:
            console.log('正常關閉遊戲連接');
            break;
        case 1006:
            console.log('遊戲連接異常中斷，可能需要重新連線');
            break;
        case 1011:
            console.log('遊戲服務器錯誤');
            break;
        default:
            console.log('遊戲連接關閉，代碼:', event.code);
    }
};
</div>
                </div>

                <div class="section">
                    <h3>🎯 遊戲流程圖</h3>
                    <div class="code-block">IDLE → game_started → round_started → countdown → waiting_player →
  result → game_finished →（前端 stopGame）→ IDLE</div>
                </div>


        <!-- 手勢繪畫 WebSocket -->
        <div class="endpoint-card">
            <div class="endpoint-header" onclick="toggleEndpoint(this)">
                <div>
                    <span class="endpoint-method">WS</span>
                    <span class="endpoint-url">/ws/drawing</span>
                    <div class="endpoint-description">即時手勢繪畫控制</div>
                </div>
                <span class="toggle-arrow">▶</span>
            </div>
            <div class="endpoint-content">
                <div class="section">
                    <h3>📋 功能說明</h3>
                    <p>處理即時手勢控制的繪畫功能，支援空中手勢繪畫、顏色選擇和畫布清空。</p>
                </div>

                <div class="section">
                    <h3>📤 客戶端發送訊息</h3>

                    <div class="message-example">
                        <div class="message-type">啟動手勢繪畫 (Start Gesture Drawing)</div>
                        <pre>{
  "type": "start_gesture_drawing",
  "mode": "gesture_control",
  "color": "blue",
  "canvas_size": [720, 1280],
  "timestamp": 1640995200.123
}</pre>
                    </div>

                    <div class="message-example">
                        <div class="message-type">攝影機幀 (Camera Frame)</div>
                        <pre>{
  "type": "camera_frame",
  "image": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQ...",
  "timestamp": 1640995200.123
}</pre>
                    </div>

                    <div class="message-example">
                        <div class="message-type">停止繪畫 (Stop Drawing)</div>
                        <pre>{
  "type": "stop_drawing",
  "timestamp": 1640995200.123
}</pre>
                    </div>
                </div>

                <div class="section">
                    <h3>📥 服務器回應訊息</h3>

                    <div class="message-example">
                        <div class="message-type">繪畫開始確認 (Drawing Started)</div>
                        <pre>{
  "type": "drawing_started",
  "session_id": "gesture_12345",
  "canvas_size": [720, 1280],
  "timestamp": 1640995200.123
}</pre>
                    </div>

                    <div class="message-example">
                        <div class="message-type">手勢狀態更新 (Gesture Status)</div>
                        <pre>{
  "type": "gesture_status",
  "current_gesture": "drawing",
  "fingers_up": [false, true, false, false, false],
  "drawing_position": [320, 240],
  "timestamp": 1640995200.123
}</pre>
                    </div>

                    <div class="message-example">
                        <div class="message-type">畫布更新 (Canvas Update)</div>
                        <pre>{
  "type": "canvas_update",
  "canvas_base64": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAA...",
  "stroke_count": 15,
  "current_color": "blue",
  "timestamp": 1640995200.123
}</pre>
                    </div>

                    <div class="message-example">
                        <div class="message-type">AI識別結果 (AI Recognition)</div>
                        <pre>{
  "type": "recognition_result",
  "recognized_shape": "circle",
  "confidence": 0.87,
  "message": "我看到一個圓形！(非常確定)",
  "timestamp": 1640995200.123
}</pre>
                    </div>

                    <div class="message-example">
                        <div class="message-type">錯誤訊息 (Error Message)</div>
                        <pre>{
  "type": "error",
  "message": "MediaPipe 初始化失敗",
  "error_code": "MEDIA_PIPE_ERROR",
  "timestamp": 1640995200.123
}</pre>
                    </div>
                </div>

                <div class="section">
                    <h3>🤏 手勢說明</h3>
                    <table class="table">
                        <tr>
                            <th>手勢</th>
                            <th>說明</th>
                            <th>對應動作</th>
                        </tr>
                        <tr>
                            <td><strong>👆 食指伸出</strong></td>
                            <td>僅食指伸直，其他手指彎曲</td>
                            <td>繪畫模式 - 使用食指尖端繪畫</td>
                        </tr>
                        <tr>
                            <td><strong>✌️ 雙指伸出</strong></td>
                            <td>食指和中指伸直</td>
                            <td>選擇模式 - 橡皮擦功能</td>
                        </tr>
                        <tr>
                            <td><strong>✋ 五指全開</strong></td>
                            <td>所有手指完全伸直</td>
                            <td>清空模式 - 清空整個畫布</td>
                        </tr>
                    </table>
                </div>

                <div class="section">
                    <h3>⚙️ 效能參數</h3>
                    <table class="table">
                        <tr><th>參數</th><th>建議值</th><th>說明</th></tr>
                        <tr><td>幀率</td><td>20-30 FPS</td><td>平衡即時性和處理效能</td></tr>
                        <tr><td>影像解析度</td><td>動態適應</td><td>自動適應攝影機實際解析度 (如 1920x1080, 1280x720 等)</td></tr>
                        <tr><td>手勢穩定性</td><td>3幀確認</td><td>避免抖動誤觸</td></tr>
                        <tr><td>網路延遲</td><td>< 50ms</td><td>確保即時互動體驗</td></tr>
                    </table>
                </div>

                <div class="section">
                    <h3>🔌 連接管理</h3>

                    <h4>連接方式</h4>
                    <div class="code-block">// 手勢繪畫 WebSocket，需要先發送啟動訊息
const ws = new WebSocket('ws://localhost:8896/ws/drawing');

ws.onopen = () => {
    console.log('已連接手勢繪畫 WebSocket');
    // 連接後需要發送 start_gesture_drawing 訊息來初始化繪畫會話
};
</div>

                    <h4>關閉連接</h4>
                    <div class="code-block">// 正常關閉 (1000) - 用戶結束繪畫會話
ws.close(1000, '手勢繪畫會話結束');

// 停止繪畫後關閉
// 先發送 stop_drawing 訊息，然後關閉連接
ws.send(JSON.stringify({
    type: 'stop_drawing',
    timestamp: Date.now() / 1000
}));
// 等待最後的 canvas_update 回應，然後:
ws.close(1000, '繪畫會話正常結束');

// 監聽關閉事件
ws.onclose = (event) => {
    console.log('手勢繪畫 WebSocket 關閉:', {
        code: event.code,
        reason: event.reason,
        wasClean: event.wasClean
    });

    // 根據關閉代碼處理
    switch(event.code) {
        case 1000:
            console.log('正常關閉繪畫連接');
            break;
        case 1006:
            console.log('繪畫連接異常中斷');
            break;
        case 1011:
            console.log('繪畫服務器錯誤');
            break;
        default:
            console.log('繪畫連接關閉，代碼:', event.code);
    }
};
</div>
                </div>

                <div class="section">
                    <h3>💻 使用範例</h3>
                    <div class="code-block">// JavaScript 手勢繪畫整合範例
class GestureDrawingClient {
    constructor() {
        this.ws = null;
        this.canvas = document.getElementById('drawing-canvas');
        this.setupWebSocket();
        this.setupCamera();
    }

    setupWebSocket() {
        this.ws = new WebSocket('ws://localhost:8896/ws/drawing');

        this.ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            this.handleServerMessage(data);
        };
    }

    async startDrawing() {
        // 啟動攝影機
        const stream = await navigator.mediaDevices.getUserMedia({video: true});
        this.videoElement.srcObject = stream;

        // 發送啟動訊息
        this.ws.send(JSON.stringify({
            type: 'start_gesture_drawing',
            mode: 'gesture_control',
            color: 'blue',
            canvas_size: [720, 1280],
            timestamp: Date.now() / 1000
        }));
    }

    handleServerMessage(data) {
        switch(data.type) {
            case 'canvas_update':
                this.updateCanvas(data.canvas_base64);
                break;
            case 'gesture_status':
                this.updateGestureHints(data.current_gesture);
                break;
            case 'recognition_result':
                this.showRecognitionResult(data);
                break;
        }
    }
}</div>
                </div>
            </div>
        </div>

        <!-- 關閉代碼參考 -->
        <div class="endpoint-card">
            <div class="endpoint-header" onclick="toggleEndpoint(this)">
                <div>
                    <span class="endpoint-method">REF</span>
                    <span class="endpoint-url">WebSocket 關閉代碼</span>
                    <div class="endpoint-description">標準關閉代碼定義</div>
                </div>
                <span class="toggle-arrow">▶</span>
            </div>
            <div class="endpoint-content">
                <table class="table">
                    <tr>
                        <th>代碼</th>
                        <th>名稱</th>
                        <th>說明</th>
                        <th>觸發條件</th>
                    </tr>
                    <tr>
                        <td><span class="badge badge-success">1000</span></td>
                        <td>CLOSE_NORMAL</td>
                        <td>正常關閉</td>
                        <td>前端呼叫 close() 或正常結束</td>
                    </tr>
                    <tr>
                        <td><span class="badge badge-info">1001</span></td>
                        <td>CLOSE_GOING_AWAY</td>
                        <td>端點離開</td>
                        <td>頁面重新載入、導航離開</td>
                    </tr>
                    <tr>
                        <td><span class="badge badge-error">1006</span></td>
                        <td>CLOSE_ABNORMAL</td>
                        <td>異常關閉</td>
                        <td>網路中斷、伺服器崩潰</td>
                    </tr>
                    <tr>
                        <td><span class="badge badge-error">1008</span></td>
                        <td>CLOSE_POLICY_VIOLATION</td>
                        <td>違反政策</td>
                        <td>訊息格式錯誤、無效數據</td>
                    </tr>
                    <tr>
                        <td><span class="badge badge-error">1011</span></td>
                        <td>CLOSE_SERVER_ERROR</td>
                        <td>伺服器錯誤</td>
                        <td>內部處理錯誤</td>
                    </tr>
                </table>
            </div>
        </div>
    </div>
</body>
</html>
